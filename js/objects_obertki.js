//Объ­ек­ты в язы­ке Ja­va­Script яв­ля­ют­ся со­став­ны­ми зна­че­ния­ми: они пред­став­ля­ют со­бой кол­лек­ции свойств, или име­но­ван­ных зна­че­ний. Об­ра­ще­ние к свой­ст­вам мы бу­дем вы­пол­нять с ис­поль­зо­ва­ни­ем то­чеч­ной но­та­ции. Свой­ст­ва, зна­че­ния­ми ко­то­рых яв­ля­ют­ся функ­ции, мы бу­дем на­зы­вать ме­то­да­ми. Что­бы вы­звать ме­тод m объ­ек­та o, сле­ду­ет ис­поль­зо­вать ин­ст­рук­цию o.m().

//Мы уже ви­де­ли, что стро­ки об­ла­да­ют свой­ст­ва­ми и ме­то­да­ми:

var s = "hello world!";                              // Стро­ка
var word = s.substring(s.indexOf(" ")+1, s.length);  // Ис­поль­зо­ва­ние свойств стро­ки

//Од­на­ко стро­ки не яв­ля­ют­ся объ­ек­та­ми, так по­че­му же они об­ла­да­ют свой­ст­ва­ми?
//Вся­кий раз ко­гда в про­грам­ме пред­при­ни­ма­ет­ся по­пыт­ка об­ра­тить­ся к свой­ст­ву стро­ки s, ин­тер­пре­та­тор Ja­va­Script пре­об­ра­зу­ет стро­ко­вое зна­че­ние в объ­ект, как ес­ли бы был вы­пол­нен вы­зов new String(s). Этот объ­ект на­сле­ду­ет стро­ко­вые ме­то­ды и ис­поль­зу­ет­ся ин­тер­прета­то­ром для дос­ту­па к свой­ст­вам. По­сле об­ра­ще­ния к  свой­ст­ву вновь соз­дан­ный объ­ект унич­то­жа­ет­ся. (От реа­ли­за­ций не тре­бу­ет­ся факти­че­ски соз­да­вать и унич­то­жать этот про­ме­жу­точ­ный объ­ект, но они долж­ны вес­ти се­бя так, как ес­ли бы объ­ект дей­ст­ви­тель­но соз­да­вался и унич­то­жал­ся.)

//На­ли­чие ме­то­дов у чи­сло­вых и ло­ги­че­ских зна­че­ний объ­яс­ня­ет­ся те­ми же при­чи­на­ми: при об­ра­ще­нии к ка­ко­му-ли­бо ме­то­ду соз­да­ет­ся вре­мен­ный объ­ект вы­зо­вом кон­ст­рук­то­ра Number() или Boolean(), по­сле че­го про­из­во­дит­ся вы­зов ме­то­да это­го объ­ек­та. Зна­че­ния null и undefined не име­ют объ­ек­тов-обер­ток: лю­бые по­пыт­ки об­ра­тить­ся к свой­ст­вам этих зна­че­ний бу­дет вы­зы­вать ошиб­ку TypeError.

//Рас­смот­рим сле­дую­щий фраг­мент и по­ду­ма­ем, что про­ис­хо­дит при его вы­пол­не­нии:

var s = "test"; // На­чаль­ное стро­ко­вое зна­че­ние.
s.len = 4;      // Ус­та­но­вить его свой­ст­во.
var t = s.len;  // Те­перь за­про­сить зна­че­ние свой­ст­ва.

//В на­ча­ле это­го фраг­мен­та пе­ре­мен­ная t име­ет зна­че­ние undefined. Вто­рая стро­ка соз­да­ет вре­мен­ный объ­ект String, ус­та­нав­ли­ва­ет его свой­ст­во len рав­ным 4 и за­тем унич­то­жа­ет этот объ­ект. Тре­тья стро­ка соз­да­ет из ори­ги­наль­ной (не­из­ме­нен­ной) стро­ки но­вый объ­ект String и  пы­та­ет­ся про­чи­тать зна­че­ние свой­ст­ва len.
//Стро­ки не име­ют дан­но­го свой­ст­ва, по­это­му вы­ра­же­ние воз­вра­ща­ет зна­че­ние undefined. Дан­ный фраг­мент по­ка­зы­ва­ет, что при по­пыт­ке про­чи­тать зна­че­ние ка­ко­го-ли­бо свой­ст­ва (или вы­звать ме­тод) стро­ки чис­ла и  ло­ги­че­ские зна­че­ния ве­дут се­бя по­доб­но объ­ек­там. Но ес­ли по­пы­тать­ся ус­та­но­вить зна­че­ние свой­ст­ва, эта по­пыт­ка бу­дет про­сто про­иг­но­ри­ро­ва­на: из­ме­не­ние за­тро­нет толь­ко вре­мен­ный объ­ект и не бу­дет со­хра­не­но. Вре­мен­ные объ­ек­ты, ко­то­рые соз­да­ют­ся при об­ра­ще­нии к свой­ст­ву стро­ки, чис­ла или ло­ги­че­ско­го зна­че­ния, на­зы­ва­ют­ся объ­ек­та­ми-оберт­ка­ми, и ино­гда мо­жет по­тре­бо­вать­ся от­ли­чать стро­ки от объ­ек­тов String или чис­ла и ло­ги­че­ские зна­че­ния от объ­ек­тов Number и Boolean. Од­на­ко обыч­но объ­ек­ты-оберт­ки мож­но рас­смат­ри­вать про­сто как осо­бен­ность реа­ли­за­ции и во­об­ще не ду­мать о них. Вам дос­та­точ­но бу­дет знать, что стро­ки, чис­ла и ло­ги­че­ские зна­че­ния от­ли­ча­ют­ся от объ­ек­тов тем, что их свой­ст­ва дос­туп­ны толь­ко для чте­ния и что вы не мо­же­те оп­ре­де­лять для них но­вые свой­ст­ва.

//Об­ра­ти­те вни­ма­ние, что су­ще­ст­ву­ет воз­мож­ность (но в этом поч­ти ни­ко­гда нет не­об­хо­ди­мо­сти или смыс­ла) яв­но соз­да­вать объ­ек­ты-обертки вы­зо­вом кон­ст­рук­то­ра String(), Number() или Boolean():

var s = "test", n = 1, b = true;	//Стро­ка, чсло и ло­ги­че­ское зна­че­ние.
var S = new String(s); 			//Объ­ект String
var N = new Number(n);  		//Объ­ект Number
var B = new Boolean(b); 		//Объ­ект Boolean

//При не­об­хо­ди­мо­сти ин­тер­пре­та­тор Ja­va­Script обыч­но ав­то­ма­ти­че­ски пре­об­ра­зу­ет объ­ек­ты-оберт­ки, т. е. объ­ек­ты S, N и B в при­ме­ре вы­ше, в обер­ты­вае­мые ими про­стые зна­че­ния, но они не все­гда ве­дут се­бя точ­но так же, как зна­че­ния s, n и b.
//Опе­ра­тор ра­вен­ст­ва == счи­та­ет рав­ны­ми зна­че­ния и со­от­вет­ст­вую­щие им объ­ек­ты-оберт­ки, но опе­ра­тор иден­тич­но­сти === от­ли­ча­ет их. Опе­ра­тор typeof так­же об­на­ру­жи­ва­ет от­ли­чия ме­ж­ду про­сты­ми зна­че­ния­ми и их объ­ек­та­ми-оберт­ка­ми.


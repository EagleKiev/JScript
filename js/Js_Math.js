'use strict';
/*Math.pow(2,53)           //=> 9007199254740992: 2 в степени 53
Math.round(.6)           //=> 1.0: округление до ближайшего целого
Math.ceil(.6)            //=> 1.0: округление вверх
Math.floor(.6)           //=> 0.0: округление вниз
Math.abs(-5)             //=> 5: абсолютное значение
Math.max(x,y,z)          //Возвращает наибольший аргумент
Math.min(x,y,z)          //Возвращает наименьший аргумент
Math.random()            //Псевдослучайное число x, где 0 <= x < 1.0
Math.PI                  //π: длина окружности / диаметр (число Пи)
Math.E                   //e: Основание натурального логарифма
Math.sqrt(3)             //Корень квадратный из 3
Math.pow(3, 1/3)         //Корень кубический из 3
Math.sin(0)              //Тригонометрия: имеются также Math.cos, Math.atan и другие.
Math.log(10)             //Натуральный логарифм 10
Math.log(100)/Math.LN10  //Логарифм 100 по основанию 10 (десятичный)
Math.log(512)/Math.LN2   //Логарифм 512 по основанию 2
Math.exp(3)              //Math.E в ку­бе

//В JavaScript имеются предопределенные глобальные переменные Infinity и NaN,хранящие значения положительной
// бесконечности и «не число». В стандарте ECMA­Script 3 эти переменные доступны для чтения/записи и могут
// изменяться в программах. Стандарт ECMAScript  5 исправляет эту оплошность и  требует, чтобы эти переменные были
// доступны только для чтения. Объект Number предоставляет альтернативные представления некоторых значений,
// доступные только для чтения даже в ECMAScript 3. Например:

Infinity                   //Переменная, доступная для чтения/записи,
                           //инициализированная значением Infinity
Number.POSITIVE_INFINITY   //То же значение, доступное только для чтения.
1/0                        //То же самое значение.
Number.MAX_VALUE + 1       //Это выражение также возвращает Infinity.

Number.NEGATIVE_INFINITY   // Возвращают отрицательную бесконечность.
-Infinity
-1/0
-Number.MAX_VALUE - 1

NaN                        //Переменная, доступная для чтения/записи,
                           //инициализированная значением NaN.
Number.NaN                 //Свойство, доступное только для чтения, с тем же значением.
0/0                        //Возвращает NaN

Number.MIN_VALUE/2         // Потеря значащих разрядов: возвращает 0
-Number.MIN_VALUE/2        // Отрицательный ноль
-1/Infinity                // Также отрицательный ноль
-0

//Значение «не число» в JavaScript обладает одной необычной особенностью: операция проверки на равенство всегда
// возвращает отрицательный результат, даже если сравнить его с самим собой. Это означает, что нельзя использовать
// проверку x == NaN, чтобы определить, является значение переменной x значением NaN. Вместо этого следует выполнять
// проверку x != x. Эта проверка вернет true тогда и только тогда, когда x имеет значение NaN. Аналогичную проверку
// можно выполнить с помощью функции isNaN(). Она возвращает true, если аргумент имеет значение NaN или если аргумент
// является нечисловым значением, таким как строка или объект. Родственная функция isFinite() возвращает true, если
// аргумент является числом, отличным от NaN, Infinity или -Infinity. Отрицательный ноль также имеет свои характерные
// особенности. В  операциях сравнения (даже в операции строгой проверки на равенство) он признается равным
// положительному нулю, что делает эти два значения практически неотличимыми, за исключением случаев, когда они
// выступают в роли делителей:

var zero = 0;      //Обычный ноль
var negz = -0;     //Отрицательный ноль
zero === negz      //=> true: ноль и отрицательный ноль равны
1/zero === 1/negz  //=> false: Infinity и -Infinity не равны

//Точность представления вещественных чисел в JavaScript достаточно высока и позволяет обеспечить очень близкое
// представление числа 0.1. Но тот факт, что это число не может быть представлено точно, может приводить к
// проблемам. Взгляните на следующий фрагмент:
// вычесления нельзя сравнивать!!!!!!*/

let a = .9 - .8;
let b = .8 - .7;
let c = .7 - .6;
let d = .6 - .5;
let e = .5 - .4;
let f = .4 - .3;
let g = .2 - .1;        //тридцать копеек минус двадцать копеек
                        //двадцать копеек минус 10 копеек
//x == y;               //=> false: получились два разных значения!
//x == .1;              //=> false: .3-.2 не равно .1
//y == .1;              //=> true: .2-.1 равно .1

//Изза ошибок округления разность между аппроксимациями чисел .3 и .2 оказалась не равной разности между
// аппроксимациями чисел .2 и .1.
// Важно понимать, что эта проблема не является чемто характерным для JavaScript: она проявляется во всех языках
// программирования, где используется двоичное представление вещественных чисел. Кроме того, обратите внимание,
// что значения x и y в примере выше очень близки друг к другу и к истинному значению. Точность округления вполне
// приемлема для большинства применений: проблема возникает лишь при попытках проверить значения на равенство. В
// будущих версиях JavaScript может появиться поддержка десятичных чисел, лишенная описанных недостатков, связанных
// с округлением. Но до тех пор для важных финансовых расчетов предпочтительнее будет использовать масштабируемые
// целые числа. Например, финансовые расчеты можно производить в копейках, а не в долях рублей.



console.log(a)
console.log(b)
console.log(c)
console.log(d)
console.log(e)
console.log(f)
console.log(g)
//console.log(typeof x)
//console.log(typeof y)
//console.log(x - y)
//console.log(x == .1)
//console.log(y == .1)
console.log(a+b+c+d+e+f+g)

console.log('');

let i = 10;
console.log(++i);


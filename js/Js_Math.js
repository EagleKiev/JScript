'use strict';
Math.pow(2,53)           //=> 9007199254740992: 2 в сте­пе­ни 53
Math.round(.6)           //=> 1.0: ок­руг­ле­ние до бли­жай­ше­го це­ло­го
Math.ceil(.6)            //=> 1.0: ок­руг­ле­ние вверх
Math.floor(.6)           //=> 0.0: ок­руг­ле­ние вниз
Math.abs(-5)             //=> 5: аб­со­лют­ное зна­че­ние
Math.max(x,y,z)          //Воз­вра­ща­ет наи­боль­ший ар­гу­мент
Math.min(x,y,z)          //Воз­вра­ща­ет наи­мень­ший ар­гу­мент
Math.random()            //Псев­до­слу­чай­ное чис­ло x, где 0 <= x < 1.0
Math.PI                  //π: дли­на ок­руж­но­сти / диа­метр (число Пи)
Math.E                   //e: Ос­но­ва­ние на­ту­раль­но­го ло­га­риф­ма
Math.sqrt(3)             //Ко­рень квад­рат­ный из 3
Math.pow(3, 1/3)         //Ко­рень ку­би­че­ский из 3
Math.sin(0)              //Три­го­но­мет­рия: име­ют­ся так­же Math.cos, Math.atan и дру­гие.
Math.log(10)             //На­ту­раль­ный ло­га­рифм 10
Math.log(100)/Math.LN10  //Ло­га­рифм 100 по ос­но­ва­нию 10 (де­ся­тич­ный)
Math.log(512)/Math.LN2   //Ло­га­рифм 512 по ос­но­ва­нию 2
Math.exp(3)              //Math.E в ку­бе

//В Ja­va­Script име­ют­ся пре­до­пре­де­лен­ные гло­баль­ные пе­ре­мен­ные Infinity и NaN,хра­ня­щие зна­че­ния по­ло­жи­тель­ной бес­ко­неч­но­сти и  «не чис­ло». В  стан­дар­те ECMA­Script 3 эти пе­ре­мен­ные дос­туп­ны для чте­ния/за­пи­си и мо­гут из­ме­нять­ся в  про­грам­мах. Стан­дарт ECMAScript  5 ис­прав­ля­ет эту оп­лош­ность и  тре­бу­ет, что­бы эти пе­ре­мен­ные бы­ли дос­туп­ны толь­ко для чте­ния. Объ­ект Number пре­дос­тав­ля­ет аль­тер­на­тив­ные пред­став­ле­ния не­ко­то­рых зна­че­ний, дос­туп­ные толь­ко для чте­ния да­же в ECMA­Script 3. На­при­мер:

Infinity                   //Пе­ре­мен­ная, дос­туп­ная для чте­ния/за­пи­си,
                           //ини­циа­ли­зи­ро­ван­ная зна­че­ни­ем Infinity
Number.POSITIVE_INFINITY   //То же зна­че­ние, дос­туп­ное толь­ко для чте­ния.
1/0                        //То же са­мое зна­че­ние.
Number.MAX_VALUE + 1       //Это вы­ра­же­ние так­же воз­вра­ща­ет Infinity.

Number.NEGATIVE_INFINITY   // Воз­вра­ща­ют от­ри­ца­тель­ную бес­ко­неч­ность.
-Infinity
-1/0
-Number.MAX_VALUE - 1

NaN                        //Пе­ре­мен­ная, дос­туп­ная для чте­ния/за­пи­си,
                           //ини­циа­ли­зи­ро­ван­ная зна­че­ни­ем NaN.
Number.NaN                 //Свой­ст­во, дос­туп­ное толь­ко для чте­ния, с тем же зна­че­ни­ем.
0/0                        //Воз­вра­ща­ет NaN

Number.MIN_VALUE/2         // По­те­ря зна­ча­щих раз­ря­дов: воз­вра­ща­ет 0
-Number.MIN_VALUE/2        // От­ри­ца­тель­ный ноль
-1/Infinity                // Так­же от­ри­ца­тель­ный ноль
-0

//Зна­че­ние «не чис­ло» в Ja­va­Script об­ла­да­ет од­ной не­обыч­ной осо­бен­но­стью: опе­ра­ция про­вер­ки на ра­вен­ст­во все­гда воз­вра­ща­ет от­ри­ца­тель­ный ре­зуль­тат, да­же ес­ли срав­нить его с са­мим со­бой. Это оз­на­ча­ет, что нель­зя ис­поль­зо­вать про­вер­ку x == NaN, что­бы оп­ре­де­лить, яв­ля­ет­ся зна­че­ние пе­ре­мен­ной x зна­че­ни­ем NaN. Вме­сто это­го сле­ду­ет вы­пол­нять про­вер­ку x != x. Эта про­вер­ка вер­нет true то­гда и толь­ко то­гда, ко­гда x име­ет зна­че­ние NaN. Ана­ло­гич­ную про­вер­ку мож­но вы­пол­нить с по­мо­щью функ­ции isNaN(). Она воз­вра­ща­ет true, ес­ли ар­гу­мент име­ет зна­че­ние NaN или ес­ли ар­гу­мент яв­ля­ет­ся не­чи­сло­вым зна­че­ни­ем, та­ким как стро­ка или объ­ект. Род­ст­вен­ная функ­ция isFinite() воз­вра­ща­ет true, ес­ли ар­гу­мент яв­ля­ет­ся чис­лом, от­лич­ным от NaN, Infinity или -Infinity. От­ри­ца­тель­ный ноль так­же име­ет свои ха­рак­тер­ные осо­бен­но­сти. В  опе­ра­ци­ях срав­не­ния (да­же в опе­ра­ции стро­гой про­вер­ки на ра­вен­ст­во) он при­зна­ет­ся рав­ным по­ло­жи­тель­но­му ну­лю, что де­ла­ет эти два зна­че­ния прак­ти­че­ски не­от­ли­чи­мы­ми, за ис­клю­че­ни­ем слу­ча­ев, ко­гда они вы­сту­па­ют в ро­ли де­ли­те­лей:

var zero = 0;      //Обыч­ный ноль
var negz = -0;     //От­ри­ца­тель­ный ноль
zero === negz      //=> true: ноль и от­ри­ца­тель­ный ноль рав­ны
1/zero === 1/negz  //=> false: Infinity и -Infinity не рав­ны

//Точ­ность пред­став­ле­ния ве­ще­ст­вен­ных чи­сел в Ja­va­Script дос­та­точ­но вы­со­ка и по­зво­ля­ет обес­пе­чить очень близ­кое пред­став­ле­ние чис­ла 0.1. Но тот факт, что это чис­ло не мо­жет быть пред­став­ле­но точ­но, мо­жет при­во­дить к про­бле­мам. Взгля­ни­те на сле­дую­щий фраг­мент:
// вычесления нельзя сравнивать!!!!!!

let a = .9 - .8;
let b = .8 - .7;
let c = .7 - .6;
let d = .6 - .5;
let e = .5 - .4;
let f = .4 - .3;
let g = .2 - .1;    //тридцать копеек минус двадцать копеек
                    //двадцать копеек минус 10 копеек
//x == y;             //=> false: получились два разных значения!
//x == .1;            //=> false: .3-.2 не равно .1
//y == .1;            //=> true: .2-.1 равно .1

//Из-за оши­бок ок­руг­ле­ния раз­ность ме­ж­ду ап­прок­си­ма­ция­ми чи­сел .3 и .2 ока­за­лась не рав­ной раз­но­сти ме­ж­ду ап­прок­си­ма­ция­ми чи­сел .2 и .1. Важ­но по­ни­мать, что эта про­бле­ма не яв­ля­ет­ся чем-то ха­рак­тер­ным для Ja­va­Script: она про­яв­ля­ет­ ся во всех язы­ках про­грам­ми­ро­ва­ния, где ис­поль­зу­ет­ся дво­ич­ное пред­став­ле­ние ве­ще­ст­вен­ных чи­сел. Кро­ме то­го, об­ра­ти­те вни­ма­ние, что зна­че­ния x и y в при­ме­ре вы­ше очень близ­ки друг к дру­гу и к ис­тин­но­му зна­че­нию. Точ­ность ок­руг­ле­ния впол­не при­ем­ле­ма для боль­шин­ст­ва при­ме­не­ний: про­бле­ма воз­ни­ка­ет лишь при по­пыт­ках про­ве­рить зна­че­ния на ра­вен­ст­во. В  бу­ду­щих вер­си­ях Ja­va­Script мо­жет по­явить­ся под­держ­ка де­ся­тич­ных чи­сел, ли­шен­ная опи­сан­ных не­дос­тат­ков, свя­зан­ных с ок­руг­ле­ни­ем. Но до тех пор для важ­ных фи­нан­со­вых рас­че­тов пред­поч­ти­тель­нее бу­дет ис­поль­зо­вать мас­шта­би­руе­мые це­лые чис­ла. На­при­мер, фи­нан­со­вые рас­че­ты мож­но про­из­во­дить в ко­пей­ках, а не в до­лях руб­лей.



console.log(a)
console.log(b)
console.log(c)
console.log(d)
console.log(e)
console.log(f)
console.log(g)
//console.log(typeof x)
//console.log(typeof y)
//console.log(x - y)
//console.log(x == .1)
//console.log(y == .1)
console.log(a+b+c+d+e+f+g)

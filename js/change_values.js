//Ме­ж­ду про­сты­ми зна­че­ния­ми (undefined, null, ло­ги­че­ски­ми зна­че­ния­ми, чис­ла­ми и стро­ка­ми) и объ­ек­та­ми (вклю­чая мас­си­вы и функ­ции) в язы­ке Ja­va­Script име­ют­ся фун­да­мен­таль­ные от­ли­чия. Про­стые зна­че­ния яв­ля­ют­ся не­из­ме­няе­мы­ми: про­стое зна­че­ние не­воз­мож­но из­ме­нить (или «транс­фор­ми­ро­вать»). Это оче­вид­но для чи­сел и ло­ги­че­ских зна­че­ний – нет ни­ка­ко­го смыс­ла из­ме­нять зна­че­ние чис­ла. Од­на­ко для строк это ме­нее оче­вид­но. По­сколь­ку стро­ки яв­ля­ют­ся мас­си­ва­ми сим­во­лов, впол­не ес­те­ст­вен­но бы­ло бы ожи­дать на­ли­чие воз­мож­но­сти из­ме­нять сим­во­лы в той или иной по­зи­ции в стро­ке. В дей­ст­ви­тель­но­сти Ja­va­Script не по­зво­ля­ет сде­лать это, и все стро­ко­вые ме­то­ды, ко­то­рые, на пер­вый взгляд, воз­вра­ща­ют из­ме­нен­ную стро­ку, на са­мом де­ле воз­вра­ща­ют но­вое стро­ко­вое зна­че­ние.

//На­при­мер:

var s = "hello"; // Из­на­чаль­но име­ет­ся не­ко­то­рый текст из строч­ных сим­во­лов
s.toUpperCase(); // Вер­нет "HELLO", но зна­че­ние s при этом не из­ме­нит­ся
s                // => "hello": ори­ги­наль­ная стро­ка не из­ме­ни­лась

//Кро­ме то­го, ве­ли­чи­ны про­стых ти­пов срав­ни­ва­ют­ся по зна­че­нию: две ве­ли­чи­ны счи­та­ют­ся оди­на­ко­вы­ми, ес­ли они име­ют од­но и то же зна­че­ние. Для чи­сел, ло­ги­че­ских зна­че­ний, null и undefined это вы­гля­дит оче­вид­ным: нет ни­ка­ко­го дру­го­го спо­со­ба срав­нить их. Од­на­ко для строк это ут­вер­жде­ние не вы­гля­дит та­ким оче­вид­ным. При срав­не­нии двух стро­ко­вых зна­че­ний Ja­va­Script счи­та­ет их оди­на­ко­вы­ми то­гда и толь­ко то­гда, ко­гда они име­ют оди­на­ко­вую дли­ну и со­дер­жат оди­на­ко­вые сим­во­лы в со­от­вет­ст­вую­щих по­зи­ци­ях.

//Объ­ек­ты от­ли­ча­ют­ся от про­стых ти­пов. Во-пер­вых, они яв­ля­ют­ся из­ме­няе­мы­ми – их зна­че­ния мож­но из­ме­нять:

var o = { x:1 }; // На­чаль­ное зна­че­ние объ­ек­та
o.x = 2;         // Из­ме­нить, из­ме­нив зна­че­ние свой­ст­ва
o.y = 3;         // Из­ме­нить, до­ба­вив но­вое свой­ст­во
var a = [1,2,3]  // Мас­си­вы так­же яв­ля­ют­ся из­ме­няе­мы­ми объ­ек­та­ми
a[0] = 0;        // Из­ме­нить зна­че­ние эле­мен­та мас­сив
a[3] = 4;        // До­ба­вить но­вый эле­мент

//Объ­ек­ты не срав­ни­ва­ют­ся по зна­че­нию: два объ­ек­та не счи­та­ют­ся рав­ны­ми, да­же ес­ли они бу­дут иметь оди­на­ко­вые на­бо­ры свойств с  одина­ко­вы­ми зна­че­ния­ми.И два мас­си­ва не счи­та­ют­ся рав­ны­ми, да­же ес­ли они име­ют один и тот же на­бор эле­мен­тов, сле­дую­щих в том же по­ряд­ке:
var o = {x:1}, p = {x:1};		//Два объ­ек­та с оди­на­ко­вы­ми свой­ст­ва­ми
o === p					//=> false: раз­ные объ­ек­ты не яв­ля­ют­ся рав­ны­ми
var a = [], b = [];			//Два раз­лич­ных пус­тых мас­си­ва
a === b					//=> false: раз­лич­ные мас­си­вы не яв­ля­ют­ся рав­ны­ми

//Что­бы под­черк­нуть от­ли­чие от про­стых ти­пов Ja­va­Script, объ­ек­ты ино­гда на­зы­ва­ют ссы­лоч­ны­ми ти­па­ми. Ес­ли сле­до­вать этой тер­ми­но­ло­гии, зна­че­ния­ми объ­ек­тов яв­ля­ют­ся ссыл­ки, и мож­но ска­зать, что объ­ек­ты срав­ни­ва­ют­ся по ссыл­ке:
//зна­че­ния двух объ­ек­тов счи­та­ют­ся рав­ны­ми то­гда и толь­ко то­гда, ко­гда они ссы­ла­ют­ся на один и тот же объ­ект в па­мя­ти.

var a = [];				//Пе­ре­мен­ная a ссы­ла­ет­ся на пус­той мас­сив.
var b = a;				//Те­перь b ссы­ла­ет­ся на тот же мас­сив.
b[0] = 1;				//Из­ме­не­ние мас­си­ва с по­мо­щью ссыл­ки в пе­ре­мен­ной b.
a[0]					//=> 1: из­ме­не­ние мож­но на­блю­дать в пе­ре­мен­ной a.
a === b					//=> true: a и b ссы­ла­ют­ся на один и тот же объ­ект, по­это­му они рав­ны.

//Как сле­ду­ет из при­ме­ра вы­ше, опе­ра­ция при­сваи­ва­ния объ­ек­та (или мас­си­ва) пе­ре­мен­ной фак­ти­че­ски при­сваи­ва­ет ссыл­ку: она не соз­да­ет но­вую ко­пию объ­ек­та. Ес­ли в про­грам­ме по­тре­бу­ет­ся соз­дать но­вую ко­пию объ­ек­та или мас­си­ва, не­об­хо­ди­мо бу­дет яв­но ско­пи­ро­вать свой­ст­ва объ­ек­та или эле­мен­ты мас­си­ва. Сле­дую­щий при­мер де­мон­ст­ри­ру­ет та­кое ко­пи­ро­ва­ние с по­мо­щью цик­ла for.

var a = ['a','b','c'];			//Ко­пи­руе­мый мас­сив
var b = [];				//Мас­сив, ку­да вы­пол­ня­ет­ся ко­пи­ро­ва­ние
for(var i = 0; i < a.length; i++) {	//Для ка­ж­до­го эле­мен­та в мас­си­ве a[]
    b[i] = a[i];			//Ско­пи­ро­вать эле­мент a[] в b[]
}

//Точ­но так же, ес­ли по­тре­бу­ет­ся срав­нить два от­дель­ных объ­ек­та или мас­си­ва, не­об­хо­ди­мо бу­дет срав­нить зна­че­ния их свойств или эле­мен­тов. Ни­же при­во­дит­ся оп­ре­де­ле­ние функ­ции, срав­ни­ваю­щей два мас­си­ва:

function equalArrays(a,b) {
    if (a.length != b.length) return false;  //Мас­си­вы раз­ной дли­ны не рав­ны
        for(var i = 0; i < a.length; i++)    //Цикл по всем эле­мен­там
            if (a[i] !== b[i]) return false; //Ес­ли хоть один эле­мент
                                             //от­ли­ча­ет­ся, мас­си­вы не рав­ны
        return true;                         //Ина­че они рав­ны
}


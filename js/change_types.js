//Ja­va­Script мо­жет гиб­ко пре­об­ра­зо­вы­вать один тип в дру­гой. Мы уже мог­ли убе­дить­ся в  этом на при­ме­ре ло­ги­че­ских зна­че­ний: вез­де, где ин­тер­пре­та­тор Ja­va­Script ожи­да­ет по­лу­чить ло­ги­че­ское зна­че­ние, мож­но ука­зать зна­че­ние лю­бо­го ти­па и  Ja­va­Script ав­то­ма­ти­че­ски вы­пол­нит не­об­хо­ди­мое пре­об­ра­зо­ва­ние. Од­ни зна­че­ния («ис­тин­ные» зна­че­ния) пре­об­ра­зу­ют­ся в зна­че­ние true, а дру­гие («лож­ные») – в false. То же от­но­сит­ся и к дру­гим ти­пам: ес­ли ин­тер­пре­та­тор ожи­да­ет по­лу­чить стро­ку, он ав­то­ма­ти­че­ски пре­об­ра­зу­ет лю­бое дру­гое зна­че­ние в стро­ку.
//Ес­ли ин­тер­пре­та­тор ожи­да­ет по­лу­чить чис­ло, он по­про­бу­ет пре­об­ра­зо­вать имею­щее­ся зна­че­ние в  чис­ло (в  слу­чае не­воз­мож­но­сти та­ко­го пре­об­ра­зо­ва­ния бу­дет по­лу­че­но зна­че­ние NaN). На­при­мер:

10 + " objects"  //=> "10 objects". Чис­ло 10 пре­об­ра­зу­ет­ся в стро­ку
"7" * "4"        //=> 28: обе стро­ки пре­об­ра­зу­ют­ся в чис­ла
var n = 1 - "x"; //=> NaN: стро­ка "x" не мо­жет быть пре­об­ра­зо­ва­на в чис­ло
n + " objects"   //=> "NaN objects": NaN пре­об­ра­зу­ет­ся в стро­ку "NaN"

//опи­сы­ва­ет­ся, как в Ja­va­Script вы­пол­ня­ет­ся пре­об­ра­зо­ва­ние зна­че­ний из од­но­го ти­па в дру­гой. Жир­ным шриф­том в таб­ли­це вы­де­ле­ны зна­че­ния, со­от­вет­ст­вую­щие пре­об­ра­зо­ва­ни­ям, ко­то­рые мо­гут пре­под­но­сить сюр­при­зы. Пус­тые ячей­ки со­от­вет­ст­ву­ют си­туа­ци­ям, ко­гда пре­об­ра­зо­ва­ние не тре­бу­ет­ся и не вы­пол­ня­ет­ся. Пре­об­ра­зо­ва­ния од­но­го про­сто­го ти­па в дру­гой, вы­пол­ня­ют­ся от­но­си­тель­но про­сто. Пре­об­ра­зо­ва­ние в ло­ги­че­ский тип уже об­су­ж­да­лось. Пре­об­ра­зо­ва­ние всех про­стых ти­пов в стро­ку чет­ко оп­ре­де­ле­но. Пре­об­ра­зо­ва­ние в чис­ло вы­пол­ня­ет­ся не­мно­го слож­нее. Стро­ки, ко­то­рые мо­гут быть пре­об­ра­зо­ва­ны в  чис­ла, пре­об­ра­зу­ют­ся в  чис­ла. В  стро­ке до­пус­ка­ет­ся на­ли­чие про­бель­ных сим­во­лов в на­ча­ле и в кон­це, но при­сут­ст­вие дру­гих не­про­бель­ных сим­во­лов, ко­то­рые не мо­гут быть ча­стью чис­ла, при пре­об­ра­зо­ва­нии стро­ки в чис­ло при­во­дят к  воз­вра­ту зна­че­ния NaN. Не­ко­то­рые осо­бен­но­сти пре­об­ра­зо­ва­ния зна­че­ний в  чис­ла мо­гут по­ка­зать­ся стран­ны­ми: зна­че­ние true пре­об­ра­зу­ет­ся в чис­ло 1, а зна­че­ние false и пус­тая стро­ка "" пре­об­ра­зу­ют­ся в 0.

//Пре­об­ра­зо­ва­ние про­стых ти­пов в объ­ек­ты так­же вы­пол­ня­ет­ся дос­та­точ­но про­сто:
//зна­че­ния про­стых ти­пов пре­об­ра­зу­ют­ся в  со­от­вет­ст­вую­щие объ­ек­ты-оберт­ки, как ес­ли бы вы­зы­вал­ся кон­ст­рук­тор String(), Number() или Boolean(). Ис­клю­че­ние со­став­ля­ют зна­че­ния null и undefined: лю­бая по­пыт­ка ис­поль­зо­вать их в  кон­тек­сте, где тре­бу­ет­ся объ­ект, вме­сто пре­об­ра­зо­ва­ния бу­дет при­во­дить к воз­бу­ж­де­нию ис­клю­че­ния TypeError. Пре­об­ра­зо­ва­ние объ­ек­тов в  про­стые ти­пы вы­пол­ня­ет­ся зна­чи­тель­но слож­нее.

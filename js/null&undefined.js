//Клю­че­вое сло­во null в язы­ке Ja­va­Script име­ет спе­ци­аль­ное на­зна­че­ние и обыч­но ис­поль­зу­ет­ся для обо­зна­че­ния от­сут­ст­вия зна­че­ния. Опе­ра­тор typeof для зна­че­ния null воз­вра­ща­ет стро­ку «object», что го­во­рит о том, что зна­че­ние null яв­ля­ет­ся спе­ци­аль­ным «пус­тым» объ­ектом. Од­на­ко на прак­ти­ке зна­че­ние null обыч­но счи­та­ет­ся един­ст­вен­ным чле­ном соб­ст­вен­но­го ти­па и мо­жет ис­поль­зо­вать­ся как при­знак от­сут­ст­вия зна­че­ния, та­ко­го как чис­ло, стро­ка или объ­ект. В боль­шин­ст­ве дру­гих язы­ков про­грам­ми­ро­ва­ния име­ют­ся зна­че­ния, ана­ло­гич­ные зна­че­нию null в Ja­va­Script: вам они мо­гут быть из­вест­ны как null или nil.
//В язы­ке Ja­va­Script име­ет­ся еще од­но зна­че­ние, сви­де­тель­ст­вую­щее об от­сут­ст­вии зна­че­ния. Зна­че­ние undefined, ука­зы­ваю­щее на пол­ное от­сут­ст­вие ка­ко­го-ли­бо зна­че­ния. Оно воз­вра­ща­ет­ся при об­ра­ще­нии к  пе­ре­мен­ной, ко­то­рой ни­ко­гда не при­сваи­ва­лось зна­че­ние, а  так­же к  не­су­ще­ст­вую­ще­му свой­ст­ву объ­ек­та или эле­мен­ту мас­си­ва. Кро­ме то­го, зна­че­ние undefined воз­вра­ща­ет­ся функ­ция­ми, не имею­щи­ми воз­вра­щае­мо­го зна­че­ния, и при­сваи­ва­ет­ся па­ра­мет­рам функ­ций для ар­гу­мен­тов, ко­то­рые не бы­ли пе­ре­да­ны при вы­зо­ве. Иден­ти­фи­ка­тор undefined явля­ет­ся име­нем пре­до­пре­де­лен­ной гло­баль­ной пе­ре­мен­ной (а не клю­че­вым сло­вом, как null), ко­то­рая ини­циа­ли­зи­ро­ва­на зна­че­ни­ем undefined. 

//В ECMA­Script 3 undefined яв­ля­ет­ся пе­ре­мен­ной, дос­туп­ной для чте­ния/за­пи­си, ко­то­рой мож­но при­сво­ить лю­бое дру­гое зна­че­ние. Эта про­бле­ма бы­ла ис­прав­ле­на в ECMA­Script 5, и  в  реа­ли­за­ци­ях Ja­va­Script, со­от­вет­ст­вую­щих это­му стан­дар­ту, пе­ре­мен­ная undefined дос­туп­на толь­ко для чте­ния. Опе­ра­тор typeof для зна­че­ния undefined воз­вра­ща­ет стро­ку «undefined», по­ка­зы­ваю­щую, что дан­ное зна­че­ние яв­ля­ет­ся един­ст­вен­ным чле­ном спе­ци­аль­но­го ти­па.

//Не­смот­ря на эти от­ли­чия, оба зна­че­ния, null и undefined, яв­ля­ют­ся при­зна­ком от­сут­ст­вия зна­че­ния и час­то яв­ля­ют­ся взаи­мо­за­ме­няе­мы­ми. Опе­ра­тор ра­вен­ст­ва == счи­та­ет их рав­ны­ми. (Что­бы от­ли­чать их в про­грам­ме, мож­но ис­поль­зо­вать опе­ра­тор иден­тич­но­сти ===.) Оба они яв­ля­ют­ся лож­ны­ми зна­че­ния­ми – в  ло­ги­че­ском кон­тек­сте они ин­тер­пре­ти­ру­ют­ся как зна­че­ние false. Ни null, ни undefined не име­ют ка­ких-ли­бо свойств или ме­то­дов. На прак­ти­ке по­пыт­ка ис­поль­зо­вать . или [], что­бы об­ра­тить­ся к свой­ст­ву или ме­то­ду этих зна­че­ний, вы­зыва­ет ошиб­ку TypeError.
//Зна­че­ние undefined мож­но рас­смат­ри­вать как при­знак не­ожи­дан­но­го или оши­боч­но­го от­сут­ст­вия ка­ко­го-ли­бо зна­че­ния, а null – как при­знак обыч­но­го или впол­не ожи­дае­мо­го от­сут­ст­вия зна­че­ния. Ес­ли в про­грам­ме по­тре­бу­ет­ся при­сво­ить од­но из этих зна­че­ний пе­ре­мен­ной или свой­ст­ву или пе­ре­дать од­но из этих зна­че­ний функ­ции, прак­ти­че­ски все­гда пред­поч­ти­тель­нее ис­поль­зо­вать зна­че­ние null.

//Не­смот­ря на то что мно­гие пре­об­ра­зо­ва­ния ти­пов Ja­va­Script вы­пол­ня­ет ав­то­ма­ти­че­ски, ино­гда мо­жет ока­зать­ся не­об­хо­ди­мым вы­пол­нить пре­об­ра­зо­ва­ние яв­но или ока­жет­ся пред­поч­ти­тель­ным вы­пол­нить яв­ное пре­об­ра­зо­ва­ние, что­бы обес­пе­чить яс­ность про­грамм­но­го ко­да.

//Про­стей­ший спо­соб вы­пол­нить пре­об­ра­зо­ва­ние ти­па яв­но за­клю­ча­ет­ся в ис­поль­зо­ва­нии функ­ций Boolean(), Number(), String() и Object(). Мы уже ви­де­ли, как эти функ­ции ис­поль­зу­ют­ся в ро­ли кон­ст­рук­то­ров объ­ек­тов-обер­ток (раз­дел 3.6). При вы­зо­ве без опе­ра­то­ра new они дей­ст­ву­ют как функ­ции пре­об­ра­зо­ва­ния и вы­пол­ня­ют пре­об­ра­зо­ва­ния, пе­ре­чис­лен­ные.

Number("3")    // => 3
String(false)  // => "false" или мож­но ис­поль­зо­вать false.toString()
Boolean([])    // => true
Object(3)      // => new Number(3)

//Об­ра­ти­те вни­ма­ние, что все зна­че­ния, кро­ме null или undefined, име­ют ме­тод toString(), ре­зуль­та­том ко­то­ро­го обыч­но яв­ля­ет­ся то же зна­че­ние, ко­то­рое воз­вра­ща­ет­ся функ­ци­ей String(). Кро­ме то­го, об­ра­ти­те вни­ма­ние, что в табл. 3.2 от­ме­ча­ет­ся, что при по­пыт­ке пре­об­ра­зо­вать зна­че­ние null или undefined в  объ­ект воз­бу­ж­да­ет­ся ошиб­ка TypeError. Функ­ция Object() в  этом слу­чае не воз­бу­ж­да­ет ис­клю­че­ние, вме­сто это­го она про­сто воз­вра­ща­ет но­вый пус­той объ­ект.

//Оп­ре­де­лен­ные опе­ра­то­ры в язы­ке Ja­va­Script не­яв­но вы­пол­ня­ют пре­об­ра­зо­ва­ния и ино­гда мо­гут ис­поль­зо­вать­ся для пре­об­ра­зо­ва­ния ти­пов. Ес­ли один из опе­ран­дов опе­ра­то­ра + яв­ля­ет­ся стро­кой, то дру­гой опе­ранд так­же пре­об­ра­зу­ет­ся в стро­ку. Унар­ный опе­ра­тор + пре­об­ра­зу­ет свой опе­ранд в чис­ло. А унар­ный опе­ра­тор ! пре­об­ра­зу­ет опе­ранд в ло­ги­че­ское зна­че­ние и ин­вер­ти­ру­ет его. Все это ста­ло при­чи­ной по­яв­ле­ния сле­дую­щих свое­об­раз­ных спо­со­бов пре­об­ра­зо­ва­ния ти­пов, ко­то­рые мож­но встре­тить на прак­ти­ке:

x + ""		// То же, что и String(x)
+x		// То же, что и Number(x). Мож­но так­же встре­тить x-0
!!x		// То же, что и Boolean(x). Об­ра­ти­те вни­ма­ние на два зна­ка !

//Фор­ма­ти­ро­ва­ние и пар­синг чи­сел яв­ля­ют­ся наи­бо­лее ти­пич­ны­ми за­да­ча­ми, ре­шае­мы­ми ком­пь­ю­тер­ны­ми про­грам­ма­ми, и по­то­му в Ja­va­Script име­ют­ся спе­циа­ли­зи­ро­ван­ные функ­ции и ме­то­ды, обес­пе­чи­ваю­щие бо­лее пол­ный кон­троль над пре­об­ра­зо­ва­ния­ми чи­сел в стро­ки и строк в чис­ла. Ме­тод toString() клас­са Number при­ни­ма­ет не­обя­за­тель­ный ар­гу­мент, оп­ре­де­ляю­щий ос­но­ва­ние сис­те­мы счис­ле­ния для пре­об­ра­зо­ва­ния. Ес­ли этот ар­гу­мент не оп­ре­де­лен, пре­об­ра­зо­ва­ние вы­пол­ня­ет­ся в де­ся­тич­ной сис­те­ме счис­ле­ния. Но вы мо­же­те про­из­во­дить пре­об­ра­зо­ва­ние в лю­бой сис­те­ме счис­ле­ния (с ос­но­ва­ни­ем от 2 до 36). На­при­мер:

var n = 17;
binary_string = n.toString(2);      // Вер­нет "10001"
octal_string = "0" + n.toString(8); // Вер­нет "021"
hex_string = "0x" + n.toString(16); // Вер­нет "0x11"

//При вы­пол­не­нии фи­нан­со­вых или на­уч­ных рас­че­тов мо­жет по­тре­бо­вать­ся обес­пе­чить пре­об­ра­зо­ва­ние чи­сел в стро­ки с точ­но­стью до оп­ре­де­лен­но­го чис­ла де­ся­тич­ных зна­ков или до оп­ре­де­лен­но­го ко­ли­че­ст­ва зна­ча­щих раз­ря­дов или по­лу­чать пред­став­ле­ние чи­сел в экс­по­нен­ци­аль­ной фор­ме. Для по­доб­ных пре­об­ра­зо­ва­ний чи­сел в  стро­ки класс Number оп­ре­де­ля­ет три ме­то­да. Ме­тод toFixed() пре­об­ра­зу­ет чис­ло в стро­ку, по­зво­ляя ука­зы­вать ко­ли­че­ст­во де­ся­тич­ных цифр по­сле за­пя­той. Он ни­ко­гда не воз­вра­ща­ет стро­ки с  экс­по­нен­ци­аль­ным пред­став­ле­ни­ем чи­сел. Ме­тод toExponential() пре­об­ра­зу­ет чис­ло в стро­ку в экс­по­нен­ци­аль­ном пред­став­ле­нии, ко­гда пе­ред за­пя­той на­хо­дит­ся един­ст­вен­ный знак, а по­сле за­пя­той сле­ду­ет ука­зан­ное ко­ли­че­ст­во цифр (т. е. ко­ли­че­ст­во зна­ча­щих цифр в стро­ке по­лу­ча­ет­ся на од­ну боль­ше, чем бы­ло ука­за­но при вы­зо­ве ме­то­да). Ме­тод toPrecision() пре­об­ра­зу­ет чис­ло в стро­ку, учи­ты­вая ко­ли­че­ст­во за­дан­ных зна­ча­щих раз­ря­дов. Ес­ли за­дан­ное ко­ли­че­ст­во зна­ча­щих раз­ря­дов ока­зы­ва­ет­ся не­дос­та­точ­ным для ото­бра­же­ния всей це­лой час­ти чис­ла, пре­об­ра­зо­ва­ние вы­пол­ня­ет­ся в экс­по­нен­ци­аль­ной фор­ме. Об­ра­ти­те вни­ма­ние, что все три ме­то­да ок­руг­ля­ют по­след­ние циф­ры или до­бав­ля­ют ну­ли, ес­ли это не­об­хо­ди­мо. Взгля­ни­те на сле­дую­щие при­ме­ры:

var n = 123456.789;
n.toFixed(0);          // "123457"
n.toFixed(2);          // "123456.79"
n.toFixed(5);          // "123456.78900"
n.toExponential(1);    // "1.2e+5"
n.toExponential(3);    // "1.235e+5"
n.toPrecision(4);      // "1.235e+5"
n.toPrecision(7);      // "123456.8"
n.toPrecision(10);     // "123456.7890"

//Ес­ли пе­ре­дать стро­ку функ­ции пре­об­ра­зо­ва­ния Number(), она по­пы­та­ет­ся ра­зо­брать эту стро­ку как ли­те­рал це­ло­го или ве­ще­ст­вен­но­го чис­ла. Эта функ­ция ра­бо­та­ет толь­ко с  де­ся­тич­ны­ми це­лы­ми чис­ла­ми и  не до­пус­ка­ет на­ли­чие в  стро­ке за­вер­шаю­щих сим­во­лов, не яв­ляю­щих­ся ча­стью ли­те­ра­ла чис­ла. Функ­ции parseInt() и parseFloat() (это гло­баль­ные функ­ции, а не ме­то­ды ка­ко­го-ли­бо клас­са) яв­ля­ют­ся бо­лее гиб­ки­ми. Функ­ция parseInt() ана­ли­зи­ру­ет толь­ко це­лые чис­ла, то­гда как функ­ция parseFloat() по­зво­ля­ет ана­ли­зи­ро­вать стро­ки, пред­став­ляю­щие и  це­лые, и ве­ще­ст­вен­ные чис­ла. Ес­ли стро­ка на­чи­на­ет­ся с по­сле­до­ва­тель­но­сти «0x» или «0X», функ­ция parseInt() ин­тер­пре­ти­ру­ет ее как пред­став­ле­ние ше­ст­на­дца­те­рич­но­го чис­ла. 1 Обе функ­ции, parseInt() и parseFloat(), про­пус­ка­ют на­чаль­ные про­бель­ные сим­во­лы, пы­та­ют­ся ра­зо­брать мак­си­маль­но воз­мож­ное ко­ли­че­ст­во сим­во­лов чис­ла и иг­но­ри­ру­ют все, что сле­ду­ет за ни­ми. Ес­ли пер­вый не­про­бель­ный сим­вол стро­ки не яв­ля­ет­ся ча­стью до­пус­ти­мо­го чи­сло­во­го ли­те­ра­ла, эти функ­ции воз­вра­ща­ют зна­че­ние NaN:

parseInt("3 blind mice")   //=> 3
parseFloat(" 3.14 meters") //=> 3.14
parseInt("-12.34")         //=> -12
parseInt("0xFF")           //=> 255
parseInt("0xff")           //=> 255
parseInt("-0XFF")          //=> -255
parseFloat(".1")           //=> 0.1
parseInt("0.1")            //=> 0
parseInt(".1")             //=> NaN: це­лые чис­ла не мо­гут на­чи­нать­ся с "."
parseFloat("$72.47");      //=> NaN: чис­ла не мо­гут на­чи­нать­ся с "$"

//Функ­ция parseInt() при­ни­ма­ет вто­рой не­обя­за­тель­ный ар­гу­мент, оп­ре­де­ляю­щий ос­но­ва­ние сис­те­мы счис­ле­ния для раз­би­рае­мо­го чис­ла. До­пус­ти­мы­ми яв­ля­ют­ся зна­че­ния от 2 до 36. На­при­мер:

parseInt("11", 2);         //=> 3 (1*2 + 1)
parseInt("ff", 16);        //=> 255 (15*16 + 15)
parseInt("zz", 36);        //=> 1295 (35*36 + 35)
parseInt("077", 8);        //=> 63 (7*8 + 7)
parseInt("077", 10);       //=> 77 (7*10 + 7)


//Несмотря на то что многие преобразования типов JavaScript выполняет автоматически, иногда может оказаться
//необходимым выполнить преобразование явно или окажется предпочтительным выполнить явное преобразование, что­бы
//обеспечить ясность программного кода.

//Простейший способ выполнить преобразование типа явно заключается в использовании функций Boolean(), Number(),
//String() и Object(). Мы уже видели, как эти функции используются в роли конструкторов объектов-оберток
//При вызове без оператора new они действуют как функции преобразования и выполняют преобразования, перечисленные.

Number("3")    // => 3
String(false)  // => "false" или можно использовать false.toString()
Boolean([])    // => true
Object(3)      // => new Number(3)

//Обратите внимание, что все значения, кроме null или undefined, имеют метод toString(), результатом которого
//обычно является то же значение, которое возвращается функцией String(). Кроме того, обратите внимание, что в
//табл. 3.2 отмечается, что при попытке преобразовать значение null или undefined в объект возбуждается ошибка
//TypeError. Функция Object() в этом случае не возбуждает исключение, вместо этого она просто возвращает новый
//пустой объект.

//Определенные операторы в языке JavaScript неявно выполняют преобразования и иногда могут использоваться для
//преобразования типов. Если один из операндов оператора + является строкой, то другой операнд также преобразуется
//в строку. Унарный оператор + преобразует свой операнд в число. А унарный оператор ! преобразует операнд в логическое
//значение и инвертирует его. Все это стало причиной появления следующих своеобразных способов преобразования типов,
//которые можно встретить на практике:

x + ""		// То же, что и String(x)
+x		// То же, что и Number(x). Можно также встретить x-0
!!x		// То же, что и Boolean(x). Обратите внимание на два зна­ка !

//Форматирование и парсинг чисел являются наиболее типичными задачами, решаемыми компьютерными программами, и
//потому в JavaScript имеются специализированные функции и методы, обеспечивающие более полный контроль над
//преобразованиями чисел в строки и строк в числа. Метод toString() класса Number принимает необязательный аргумент,
//определяющий основание системы счисления для преобразования. Если этот аргумент не определен, преобразование
//выполняется в десятичной системе счисления. Но вы можете производить преобразование в любой системе счисления
//(с основанием от 2 до 36). Например:

var n = 17;
binary_string = n.toString(2);      // Вернет "10001"
octal_string = "0" + n.toString(8); // Вернет "021"
hex_string = "0x" + n.toString(16); // Вернет "0x11"

//При выполнении финансовых или научных расчетов может потребоваться обеспечить преобразование чисел в строки с
//точностью до определенного числа десятичных знаков или до определенного количества значащих разрядов или получать
//представление чисел в экспоненциальной форме. Для подобных преобразований чисел в строки класс Number определяет
//три метода.

//Метод toFixed() преобразует число в строку, позволяя указывать количество десятичных цифр после запятой.
//Он никогда не возвращает строки с  экспоненциальным представлением чисел.

//Метод toExponential() преобразует число в строку в экспоненциальном представлении, когда перед запятой находится
//единственный знак, а после запятой следует указанное количество цифр (т. е. количество значащих цифр в строке
//получается на одну больше, чем было указано при вызове метода).

//Метод toPrecision() преобразует число в строку, учитывая количество заданных значащих разрядов. Если заданное
//количество значащих разрядов оказывается недостаточным для отображения всей целой части числа, преобразование
//выполняется в экспоненциальной форме. Обратите внимание, что все три метода округляют последние цифры или добавляют
//нули, если это необходимо. Взгляните на следующие примеры:

var n = 123456.789;
n.toFixed(0);          // "123457"
n.toFixed(2);          // "123456.79"
n.toFixed(5);          // "123456.78900"
n.toExponential(1);    // "1.2e+5"
n.toExponential(3);    // "1.235e+5"
n.toPrecision(4);      // "1.235e+5"
n.toPrecision(7);      // "123456.8"
n.toPrecision(10);     // "123456.7890"

//Если передать строку функции преобразования Number(), она попытается разобрать эту строку как литерал целого
//или вещественного числа. Эта функция работает только с десятичными целыми числами и не допускает наличие в
//строке завершающих символов, не являющихся частью литерала числа.

//Функции parseInt() и parseFloat() (это глобальные функции, а не методы какого-либо класса) являются более гибкими.
//Функция parseInt() анализирует только целые числа, тогда как функция parseFloat() позволяет анализировать строки,
//представляющие и целые, и вещественные числа. Если строка начинается с последовательности «0x» или «0X»,
//функция parseInt() интерпретирует ее как представление шестнадцатеричного числа. 1 Обе функции, parseInt() и
//parseFloat(), пропускают начальные пробельные символы, пытаются разобрать максимально возможное количество
//символов числа и игнорируют все, что следует за ними. Если первый непробельный символ строки не является частью
//допустимого числового литерала, эти функции возвращают значение NaN:

parseInt("3 blind mice")   //=> 3
parseFloat(" 3.14 meters") //=> 3.14
parseInt("-12.34")         //=> -12
parseInt("0xFF")           //=> 255
parseInt("0xff")           //=> 255
parseInt("-0XFF")          //=> -255
parseFloat(".1")           //=> 0.1
parseInt("0.1")            //=> 0
parseInt(".1")             //=> NaN: целые числа не могут начинаться с "."
parseFloat("$72.47");      //=> NaN: числа не могут начинаться с "$"

//Функция parseInt() принимает второй необязательный аргумент, определяющий основание системы счисления для
//разбираемого числа. Допустимыми являются значения от 2 до 36. Например:

parseInt("11", 2);         //=> 3 (1*2 + 1)
parseInt("ff", 16);        //=> 255 (15*16 + 15)
parseInt("zz", 36);        //=> 1295 (35*36 + 35)
parseInt("077", 8);        //=> 63 (7*8 + 7)
parseInt("077", 10);       //=> 77 (7*10 + 7)

